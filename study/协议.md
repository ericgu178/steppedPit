# 协议： 一组规则。要求使用协议的双方，必须严格遵守协议内容。

## 网络分层架构

>  OSI七层模型结构体： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
>  TCP/IP 四层模型：数据链路层、网络层、传输层、应用层

## 各层功能

	### 链路层 ARP协议 （它会帮助我们寻找另一台设备上的mac地址）
	
	> 源mac地址 —— 目标mac地址
	>
	> ARP 协议作用： 借助 IP 获取 mac 地址。
	>
	> arp -a 可以查看arp列表

### 网络层   IP 协议（它会帮助我们在网络当中确定一台主机）

		> 源IP —— 目标IP
		> IP协议的作用： 在 网络环境中唯一标识一台主机。
		>
		> IP地址本质：2进制数。—— 点分十进制 IP地址 （string）

### 传输层  TCP / UDP 协议 

> port —— 在 一台主机上唯一标识一个进程。

### 应用层 ftp、http、自定义协议

>对数据进行封装。 解封装。

![](通信过程.png)

### 数据通信过程

​	封装： 应用层 —— 传输层 —— 网络层 —— 链路层	。 没有经过封装的数据，不能在网络环境中传递。

​	解封装 ： 链路层 —— 网络层 —— 传输层 —— 应用层

## 总结通信过程

1. mac地址（不需要用户指定）		(ARP 协议)ip ——> mac

2. IP 地址 （需要用户指定）	—— 确定主机

3. port 端口号 （需要用户指定）	—— 确定程序

	1. 不能使用系统占用的默认端口。	尽量使用5000+以上的端口号 （特殊的除外8080）	

	2. 65535为端口上限。 

socket：   套接字。

	网络通信过程中，socket 一定是成对出现的。


网络应用设计模式：

	C/S:
		优点：数据传输效率高、协议选择灵活
	
		缺点：工作量大、安全性构成威胁
	
	B/S:
		优点：开发工作较小、不受平台限制、安全威胁小
	
		缺点：缓存数据差、协议选择不灵活、

TCP-CS服务器：

	1.  创建监听socket  listener := net.Listen("TCP", "IP+port")	IP+port	—— 服务器自己的IP 和 port
	
	2.  启动监听  conn := listener.Accept()  conn 用于 通信的 socket
	
	3.  conn.Read()  
	
	4.  处理使用 数据
	
	5.  conn.Write()
	
	6.  关闭  listener、conn

nc工具环境变量配置。

	1. 解压 netcat-win32-1.12.zip 文件 到指定目录
	
	2. 拷贝 解压后目录，保存到环境变量： 
	
		方法：我的电脑-->属性-->高级系统设置-->环境变量-->系统变量中找“path”-->双击它-->新建-->粘贴
	
	3. 启动 cmd 执行 nc 命令 充当客户端测试
	
	4. nc 127.0.01 8000 （注意 IP 和 端口之间是“空格”）
	
	5. 输入 hello socket。 服务器应该能读到并向服务器的屏幕打印 “hello socket”

TCP-CS客户端：

	1.  conn, err := net.Dial("TCP", 服务器的IP+port)
	
	2.  写数据给 服务器 conn.Write()
	
	3.  读取服务器回发的 数据 conn.Read()
	
	4.  conn.Close()

TCP-CS并发服务器：

	1.  创建 监听套接字 listener := net.Listen("tcp"， 服务器的IP+port)		// tcp 不能大写
	
	2.  defer listener.Close()
	
	3.  for 循环 阻塞监听 客户端连接事件 	conn := listener.Accept()
	
	4. 创建 go程 对应每一个 客户端进行数据通信	go HandlerConnet()
	
	5. 实现 HandlerConnet(conn net.Conn) 
	
		1) defer conn.Close()
	
		2) 获取成功连接的客户端 Addr 		conn.RemoteAddr()
	
		3) for 循环 读取 客户端发送数据		conn.Read(buf)
	
		4) 处理数据 小 —— 大	strings.ToUpper()
	
		5）回写转化后的数据		conn.Write(buf[:n]) 

服务器判断关闭：

	Read读客户端/服务器，返回 0  ——  对端关闭！
	
	nc 命令发送数据时，默认在结尾自带‘\n’

TCP-CS并发客户端：	

	1. 匿名 go 程 ， 获取 键盘输入， 写给服务器
	
	2. for 循环读取服务器回发数据
	
	发送数据时，默认在结尾自带‘ \r\n ’

TCP通信过程：

	三次握手：
	
		1. 主动发起请求端， 发送 SYN 
	
		2. 被动建立连接请求端 ， 应答ACK 同时 发送 SYN
	
		3. 主动发起请求端，发送应答 ACK
	
		标志 TCP 三次握手建立完成。 —— server：Accept() 返回 。 	—— client：Dial() 返回。
	
	四次挥手：
	
		1. 主动关闭连接请求端， 发送 FIN
	
		2. 被动关闭连接请求端 ，应答 ACK
						标志。半关闭完成。 —— close()
		3. 被动关闭连接请求端 ，发送 FIN
	
		4.  主动关闭连接请求端，应答 ACK
						标志。四次挥手建立完成。 —— close().
